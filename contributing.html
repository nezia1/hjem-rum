<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Contributing</title>
    <link rel="stylesheet" href="assets/style.css" />
    
    <script defer src="assets/search.js"></script>
    
  </head>
  <body>
    <div class="container">
      <header>
        <div class="header-left">
          <h1 class="site-title"><a href="index.html">Hjem Rum</a></h1>
        </div>
        <nav class="header-nav">
          <ul>
            <li ><a href="options.html">Options</a></li>
            
            <li><a href="search.html">Search</a></li>
            
          </ul>
        </nav>
        
        <div class="search-container">
          <input type="text" id="search-input" placeholder="Search..." />
          <div id="search-results" class="search-results"></div>
        </div>
        
      </header>

      <div class="layout">
        <div class="sidebar-toggle" aria-label="Toggle sidebar">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            width="24"
            height="24"
          >
            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
          </svg>
        </div>
        <nav id="sidebar" class="sidebar">
          <div class="docs-nav">
            <h2>Documents</h2>
            <ul>
              <li><a href="contributing.html">Contributing</a></li>
<li><a href="index.html">Hjem Rum</a></li>
<li><a href="search.html">Search</a></li>

            </ul>
          </div>

          <div class="toc">
            <h2>Contents</h2>
            <ul class="toc-list">
              <li><a href="#contributing">Contributing</a>
<ul><li><a href="#getting-started-a-name-getting-started-a">Getting Started<a name="getting-started"></a></a>
<ul><li><a href="#commit-format-a-name-commit-format-a">Commit format<a name="commit-format"></a></a>
</ul><li><a href="#core-principles-a-name-core-principles-a">Core Principles<a name="core-principles"></a></a>
<li><a href="#guidelines-a-name-guidelines-a">Guidelines<a name="guidelines"></a></a>
<ul><li><a href="#where-to-put-a-new-module-a-name-where-to-put-a-new-module-a">Where to put a new module<a name="where-to-put-a-new-module"></a></a>
<li><a href="#aliases-a-name-aliases-a">Aliases<a name="aliases"></a></a>
<li><a href="#writing-options-a-name-writing-options-a">Writing Options<a name="writing-options"></a></a>
<li><a href="#conditional-config-a-name-conditional-config-a">Conditional Config<a name="conditional-config"></a></a>
<li><a href="#extending-lib-a-name-extending-lib-a">Extending Lib<a name="extending-lib"></a></a>
<li><a href="#docs-a-name-docs-a">Docs<a name="docs"></a></a>
<li><a href="#tests-a-name-tests-a">Tests<a name="tests"></a></a>
</ul><li><a href="#reviewing-a-pr-a-name-reviewing-a-pr-a">Reviewing a PR<a name="reviewing-a-pr"></a></a>
</li></ul></li>
            </ul>
          </div>
        </nav>

        <main class="content">
          <h1>Contributing</h1>
<p>Hjem Rum (or HJR) is always in need of contributions as a module collection. As
programs are developed, modules will need to be added, changed, removed, etc.,
meaning that the development of HJR is, in essence, unending.</p>
<p>Contributing is also a great way to learn the Nix module system and even
function writing. Don’t be afraid to experiment and try learning something new.</p>
<p>If you are familiar with contributing to open source software, you can safely
skip ahead to <a href="#core-principles">Core Principles</a>. Otherwise, read the following
section to learn how to fork a repo and open a PR.</p>
<!-- mdformat-toc start --slug=github --maxlevel=6 --minlevel=2 -->
<ul>
<li><a href="#getting-started">Getting Started</a><ul>
<li><a href="#commit-format">Commit format</a></li>
</ul>
</li>
<li><a href="#core-principles">Core Principles</a></li>
<li><a href="#guidelines">Guidelines</a><ul>
<li><a href="#where-to-put-a-new-module">Where to put a new module</a></li>
<li><a href="#aliases">Aliases</a></li>
<li><a href="#writing-options">Writing Options</a></li>
<li><a href="#conditional-config">Conditional Config</a></li>
<li><a href="#extending-lib">Extending Lib</a></li>
<li><a href="#docs">Docs</a></li>
<li><a href="#tests">Tests</a></li>
</ul>
</li>
<li><a href="#reviewing-a-pr">Reviewing a PR</a></li>
</ul>
<!-- mdformat-toc end -->
<h2>Getting Started<a name="getting-started"></a></h2>
<p>To begin contributing to HJR, you will first need to create a fork off of the
main branch in order to make changes. For info on how to do this, we recommend
GitHub’s own
<a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo">documentation</a>.</p>
<p>Once you have your own fork, it is recommend that you create a branch for the
changes or additions you seek to make, to make it easier to set up multiple PRs
from your fork. To do so, you can read this
<a href="https://www.geeksforgeeks.org/how-to-create-a-new-branch-in-git/">article</a> that
will also explain branches for you. Don’t worry too much about the technical
details, the most important thing is to make and switch to a branch from HEAD.</p>
<h3>Commit format<a name="commit-format"></a></h3>
<blockquote>
<p>[!INFO] Our dev shell allows for interactive commits, through the means of
<a href="https://github.com/commitizen-tools/commitizen">commitizen</a>. If this is
preferred, you can run <code>cz commit</code> to be prompted to build your commit.</p>
</blockquote>
<p>For consistency, we do enforce a strict (but simple) commit style, that will be
linted against. The format is as follows (sections between <code>[]</code> are optional):</p>
<pre><code class="language-console">&lt;top_level_scope&gt;/[&lt;specific_scope&gt;]: &lt;message&gt;

[&lt;body&gt;]
</code></pre><ul>
<li><p>&lt;top_level_scope&gt;: the main scope of your commit. If making a change to a
program, this would be <code>programs</code>). For changes unrelated to the modules API,
we tend to use semantic scopes such as <code>meta</code> for CI/repo related changes.</p>
</li>
<li><p>[&lt;specific_scope&gt;]: An optional, more specific scope for your module. If
making changes to a specific program, this would be <code>programs/foot</code>.</p>
</li>
<li><p>&lt;message&gt;: A free form commit message. Needs to be imperative and without
punctuation (e.g. <code>do stuff</code> instead of <code>did stuff.</code>).</p>
</li>
<li><p>[&lt;body&gt;]: A free form commit body. Having one is encouraged when your
changes are difficult to explain, unless you’re writing in-depth code comments
(it is still preferred however).</p>
</li>
</ul>
<p>You can now make your changes in your editor of choice. After committing your
changes, you can run:</p>
<pre><code class="language-shell">git push origin &lt;branch-name&gt;
</code></pre><p>and then open up a PR, or “Pull Request,” in the upstream HJR repository. Again,
GitHub has good documentation for
<a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request">this</a>.</p>
<p>After you have setup a PR, it will be <a href="#reviewing-a-pr">reviewed</a> by maintainers
and changes may be requested. Make the changes requested and eventually it will
likely be accepted and merged into main.</p>
<h2>Core Principles<a name="core-principles"></a></h2>
<p>In creating HJR, we had a few principles in mind for development:</p>
<ol>
<li>Minimize the number of options written;</li>
<li>Include only the module collection - leave functionality to Hjem; and</li>
<li>Maintain readability of code, even for new users.</li>
</ol>
<p>Please keep these in mind as you read through our general guidelines for
contributing.</p>
<h2>Guidelines<a name="guidelines"></a></h2>
<p>These guidelines, are, of course, merely guidelines. There are and will continue
to be exceptions. However, do your best to stick to them, and keep in mind that
reviewers will hold you to them as much as possible.</p>
<h3>Where to put a new module<a name="where-to-put-a-new-module"></a></h3>
<p>WIP</p>
<h3>Aliases<a name="aliases"></a></h3>
<p>At the top of any module, there should always be a <code>let ... in</code> set. Within
this, functions should have their location aliased, cfg should be aliased, and
any generators should have an alias as well. Here’s an example for a module that
makes use of the TOML generator used in nixpkgs:</p>
<pre><code class="language-nix">{
  config,
  lib,
  pkgs,
  ...
}: let
  # in case you are unfamiliar, &#39;inherit func;&#39; is the same as &#39;func = func;&#39;, and
  # &#39;inherit (cfg) func;&#39; is the same as &#39;func = cfg.func;&#39;
  inherit (lib.modules) mkIf;
  inherit (lib.options) mkOption mkEnableOption mkPackageOption;

  toml = pkgs.formats.toml {};

  cfg = config.rum.programs.alacritty;
in {
  options.rum.programs.alacritty = {
</code></pre><p>Notice that each function has its location aliased with an inherit to its target
location. Ideally, this location should be where one could find it in the source
code. For example, rather than using <a href="options.html#option-lib-mkIf" class="option-reference"><code>lib.mkIf</code></a>, we use <a href="options.html#option-lib-modules-mkIf" class="option-reference"><code>lib.modules.mkIf</code></a>,
because mkIf is declared at <code>lib/modules.nix</code> within the nixpkgs repo.</p>
<p>Also notice that in this case, <code>pkgs.formats.toml {}</code> includes both <code>generate</code>
and <code>type</code>, so the alias name is just <code>toml</code>.</p>
<p>Always be sure to include <code>cfg</code> that links to the point where options are
configured by the user.</p>
<h3>Writing Options<a name="writing-options"></a></h3>
<blockquote>
<p>[!IMPORTANT] When writing options for any Nix module, do NOT make any option
depend on a value from <code>config</code>. Options should be pure, or it will interfere
with modules evaluation.</p>
</blockquote>
<p>Writing new options is the core of any new module. It is also the easiest place
to blunder. As stated above, a core principle of HJR is to minimize the number
of options as much as possible. As such, we have created a general template that
should help inform you of what options are needed and what are not:</p>
<ul>
<li><code>enable</code>: Used to toggle install and configuration of package(s).</li>
<li><code>package</code>: Used to customize and override the package installed.<ul>
<li>As needed, <code>packages</code>: List of packages used in a module.</li>
</ul>
</li>
<li><code>settings</code>: Primary configuration option, takes Nix code and converts to
target lang.<ul>
<li>As needed, one extra option for each extra file, such as <code>theme</code> for
theme.toml.</li>
</ul>
</li>
<li>As needed, <code>extraConfig</code>: Extra lines of strings passed directly to config
file for certain programs.</li>
</ul>
<p>For the most part, this should be sufficient. Overrides of packages should be
simply offered through a direct override in <code>package</code>. For example, ncmpcpp’s
package has a <code>withVisualizer ? false</code> argument. Rather than creating an extra
option for this, the contributor should note this with <code>extraDescription</code> like
so:</p>
<pre><code class="language-nix">options.rum.programs.ncmpcpp = {
  enable = mkEnableOption &quot;ncmpcpp, a mpd-based music player.&quot;;

  package = mkPackageOption pkgs &quot;ncmpcpp&quot; {
    extraDescription = &#39;&#39;
      You can use an override to toggle certain features like the visualizer, a clock screen, and more.
      Please check out the package source for a complete list.
    &#39;&#39;;
  };
</code></pre><p>and the user could simply pass:</p>
<pre><code class="language-nix">config.hjem.users.&lt;username&gt;.rum.programs.ncmpcpp = {
    enable = true;
    package = (pkgs.ncmpcpp.override {
        withVisualizer = true;
    });
};
</code></pre><p>The <code>type</code> of <code>settings</code> and other conversion options should preferably be a
<code>type</code> option exposed by the generator (for example, TOML has
<code>pkgs.formats.toml {}.type</code> and <code>pkgs.formats.toml {}.generate</code>), or, if using a
custom generator, a <code>type</code> should be created in <code>lib/types/</code> (for example,
<code>hyprType</code>). Otherwise, a simple <code>attrsOf anything</code> would suffice.</p>
<p>As a rule of thumb, submodules should not be employed. Instead, there should
only be one option per file. For some files, such as spotify-player’s
<a href="options.html#option-keymap-toml" class="option-reference"><code>keymap.toml</code></a>, you may be tempted to create multiple options for <code>actions</code> and
<code>keymaps</code>, as Home Manager does. Please avoid this. In this case, we can have a
simple <code>keymap</code> option that the user can then include a list of keymaps and/or a
list of actions that get propagated accordingly:</p>
<pre><code class="language-nix">  keymap = mkOption {
    type = toml.type;
    default = {};
    example = {
      keymaps = [
        {
          command = &quot;NextTrack&quot;;
          key_sequence = &quot;g n&quot;;
        }
      ];
      actions = [
        {
          action = &quot;GoToArtist&quot;;
          key_sequence = &quot;g A&quot;;
        }
      ];
    };
    description = &#39;&#39;
      Sets of keymaps and actions converted into TOML and written to
      &lt;code class=&quot;file-path&quot;&gt;$HOME/.config/spotify-player/keymap.toml&lt;/code&gt;.
      See example for how to format declarations.

      Please reference https://github.com/aome510/spotify-player/blob/master/docs/config.md#keymaps
      for more information.
    &#39;&#39;;
  };
</code></pre><p>Also note that the option description includes a link to upstream info on
settings options.</p>
<h3>Conditional Config<a name="conditional-config"></a></h3>
<p>Always use a <code>mkIf</code> before the config section. Example:</p>
<pre><code class="language-nix">config = mkIf cfg.enable {

};
</code></pre><p>As a general guideline, <strong>do not write empty strings to files</strong>. Not only is
this poorly optimized, but it will cause issues if a user happens to be manually
using the Hjem tooling alongside HJR. Here are some examples of how you might
avoid this:</p>
<pre><code class="language-nix">config = mkIf cfg.enable {
  packages = [cfg.package];
  files.&quot;.config/alacritty/alacritty.toml&quot;.source = mkIf (cfg.settings != {}) (
    toml.generate &quot;alacritty.toml&quot; cfg.settings
  );
};
</code></pre><p>Here all that is needed is a simple <code>mkIf</code> with a condition of the <code>settings</code>
option not being left empty. In a case where you write to multiple files, you
can use <code>optionalAttrs</code>, like so:</p>
<pre><code class="language-nix">files = (
    optionalAttrs (cfg.settings != {}) {
    &quot;.gtkrc-2.0&quot;.text = toGtk2Text {inherit (cfg) settings;};
    &quot;.config/gtk-3.0/settings.ini&quot;.text = toGtkINI {Settings = cfg.settings;};
    &quot;.config/gtk-4.0/settings.ini&quot;.text = toGtkINI {Settings = cfg.settings;};
    }
    // optionalAttrs (cfg.css.gtk3 != &quot;&quot;) {
    &quot;.config/gtk-3.0/gtk.css&quot;.text = cfg.css.gtk3;
    }
    // optionalAttrs (cfg.css.gtk4 != &quot;&quot;) {
    &quot;.config/gtk-4.0/gtk.css&quot;.text = cfg.css.gtk4;
    }
);
</code></pre><p>This essentially takes the attrset of <code>files</code> and <em>optionally</em> adds attributes
defining more files to be written to <em>if</em> the corresponding option has been set.
This is optimal because the first three files written to share an option due to
how GTK configuration works.</p>
<p>One last case is in the Hyprland, where several checks and several options are
needed to compile into one file. Here is how it is done:</p>
<pre><code class="language-nix">files = let
  check = {
    plugins = cfg.plugins != [];
    settings = cfg.settings != {};
    variables = {
      noUWSM = config.environment.sessionVariables != {} &amp;&amp; !osConfig.programs.hyprland.withUWSM;
      withUWSM = config.environment.sessionVariables != {} &amp;&amp; osConfig.programs.hyprland.withUWSM;
    };
    extraConfig = cfg.extraConfig != &quot;&quot;;
  };
in {
  &quot;.config/hypr/hyprland.conf&quot;.text = mkIf (check.plugins || check.settings || check.variables.noUWSM || check.extraConfig) (
    optionalString check.plugins (pluginsToHyprconf cfg.plugins cfg.importantPrefixes)
    + optionalString check.settings (toHyprconf {
      attrs = cfg.settings;
      inherit (cfg) importantPrefixes;
    })
    + optionalString check.variables.noUWSM (toHyprconf {
      attrs.env =
        # https://wiki.hyprland.org/Configuring/Environment-variables/#xdg-specifications
        [
          &quot;XDG_CURRENT_DESKTOP,Hyprland&quot;
          &quot;XDG_SESSION_TYPE,wayland&quot;
          &quot;XDG_SESSION_DESKTOP,Hyprland&quot;
        ]
        ++ mapAttrsToList (key: value: &quot;${key},${value}&quot;) config.environment.sessionVariables;
    })
    + optionalString check.extraConfig cfg.extraConfig
  );

  /*
  uwsm environment variables are advised to be separated
  (see https://wiki.hyprland.org/Configuring/Environment-variables/)
  */
  &quot;.config/uwsm/env&quot;.text =
    mkIf check.variables.withUWSM
    (toEnvExport config.environment.sessionVariables);

  &quot;.config/uwsm/env-hyprland&quot;.text = let
    /*
    this is needed as we&#39;re using a predicate so we don&#39;t create an empty file
    (improvements are welcome)
    */
    filteredVars =
      filterKeysPrefixes [&quot;HYPRLAND_&quot; &quot;AQ_&quot;] config.environment.sessionVariables;
  in
    mkIf (check.variables.withUWSM &amp;&amp; filteredVars != {})
    (toEnvExport filteredVars);
};
</code></pre><p>An additional attrset of boolean aliases is set within a <code>let ... in</code> set to
highlight the different checks done and to add qucik ways to reference each
check without excess and redudant code.</p>
<p>First, the file is only written if any of the options to write to the file are
set. <code>optionalString</code> is then used to compile each option’s results in an
optimized and clean way.</p>
<h3>Extending Lib<a name="extending-lib"></a></h3>
<p>Rather than having functions scattered throughout the module collection, we
would rather keep our directories organized and purposeful. Therefore, all
custom functions should go into our extended lib, found at <code>modules/lib/</code>.</p>
<p>The most common functions that might be created are a <code>generator</code> and <code>type</code>
pair. The former should be prefixed with “to” to maintain style and describe
their function: conversion <em>to</em> other formats. For example, <code>toNcmpcppSettings</code>
is the function that converts to the format required for ncmpcpp settings.</p>
<p>Likewise, types should be suffixed with “Type” to maintain style and describe
their function. For example, <code>hyprType</code> describes the type used in <code>settings</code>
converted to hyprlang.</p>
<p>When it comes to directory structure, you should be able to infer how we
organize our lib by both our folder structure itself as well as the names of
functions. For example, <a href="options.html#option-lib-rum-types-gtkType" class="option-reference"><code>lib.rum.types.gtkType</code></a> is found in
<code>lib/types/gtkType.nix</code>. In cases where a file is a single function, always be
sure to make sure the name matches the file.</p>
<p>If a program uses multiple functions of the same kind (e.g. two generators), you
can put them in one file, like is done in <code>lib/generators/gtk.nix</code>.</p>
<p>Additionally, please follow how lib is structured in nixpkgs. For example, the
custom function <code>attrsNamesHasPrefix</code> is under <code>attrsets</code> to signify that it
operates on an attrset, just like in nixpkgs.</p>
<h3>Docs<a name="docs"></a></h3>
<p>WIP</p>
<h3>Tests<a name="tests"></a></h3>
<p>WIP</p>
<h2>Reviewing a PR<a name="reviewing-a-pr"></a></h2>
<p>Even if you do not have write-access. You can always leave a review on someone
else’s PR. Again, GitHub has great
<a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/reviewing-proposed-changes-in-a-pull-request">documentation</a>
on doing so. This is great practice for learning the guidelines as well as
learning exceptions to the rules.</p>

          <div class="footnotes-container">
            <!-- Footnotes will be appended here -->
          </div>
        </main>
      </div>

      <footer>
        <p></p>
      </footer>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Sidebar Toggle
        const sidebarToggle = document.querySelector(".sidebar-toggle");
        if (sidebarToggle) {
          sidebarToggle.addEventListener("click", function () {
            document.body.classList.toggle("sidebar-collapsed");

            // Save state to localStorage
            const isCollapsed =
              document.body.classList.contains("sidebar-collapsed");
            localStorage.setItem("sidebar-collapsed", isCollapsed);
          });

          // Restore sidebar state from localStorage
          const isCollapsed =
            localStorage.getItem("sidebar-collapsed") === "true";
          if (isCollapsed) {
            document.body.classList.add("sidebar-collapsed");
          }
        }

        // Make headings clickable for anchor links
        const content = document.querySelector(".content");
        const headings = content.querySelectorAll("h1, h2, h3, h4, h5, h6");

        headings.forEach(function (heading) {
          // Make sure all headings have IDs
          if (!heading.id) {
            heading.id = heading.textContent
              .toLowerCase()
              .replace(/[^\w\s-]/g, "")
              .replace(/[\s-]+/g, "-")
              .trim();

            if (!heading.id) {
              heading.id =
                "section-" + Math.random().toString(36).substring(2, 9);
            }
          }

          // Make the entire heading clickable
          heading.addEventListener("click", function (e) {
            const id = this.id;
            history.pushState(null, null, "#" + id);

            // Scroll with offset
            const offset =
              this.getBoundingClientRect().top + window.scrollY - 80;
            window.scrollTo({
              top: offset,
              behavior: "smooth",
            });
          });
        });

        // Process footnotes
        const footnoteContainer = document.querySelector(
          ".footnotes-container",
        );

        // Find all footnote references and create a footnotes section
        const footnoteRefs = content.querySelectorAll('a[href^="#fn"]');
        if (footnoteRefs.length > 0) {
          const footnotesDiv = document.createElement("div");
          footnotesDiv.className = "footnotes";

          const footnotesHeading = document.createElement("h2");
          footnotesHeading.textContent = "Footnotes";
          footnotesDiv.appendChild(footnotesHeading);

          const footnotesList = document.createElement("ol");
          footnoteContainer.appendChild(footnotesDiv);
          footnotesDiv.appendChild(footnotesList);

          // Add footnotes
          document.querySelectorAll(".footnote").forEach((footnote) => {
            const id = footnote.id;
            const content = footnote.innerHTML;

            const li = document.createElement("li");
            li.id = id;
            li.innerHTML = content;

            // Add backlink
            const backlink = document.createElement("a");
            backlink.href = "#fnref:" + id.replace("fn:", "");
            backlink.className = "footnote-backlink";
            backlink.textContent = "↩";
            li.appendChild(backlink);

            footnotesList.appendChild(li);
          });
        }

        // Handle initial hash navigation
        function scrollToElement(element) {
          if (element) {
            const offset =
              element.getBoundingClientRect().top + window.scrollY - 80;
            window.scrollTo({
              top: offset,
              behavior: "smooth",
            });
          }
        }

        if (window.location.hash) {
          const targetElement = document.querySelector(window.location.hash);
          if (targetElement) {
            setTimeout(() => scrollToElement(targetElement), 0);
          }
        }
      });
    </script>
    
  </body>
</html>
